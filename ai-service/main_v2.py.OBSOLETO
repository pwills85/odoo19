# -*- coding: utf-8 -*-
"""
AI Microservice - Main Application V2
======================================

Enhanced with plugin system for multi-module support.

BACKWARD COMPATIBLE: All existing endpoints work exactly as before.
New functionality behind feature flags.
"""

from fastapi import FastAPI, Depends, HTTPException, Security, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
import structlog

from config import settings

# ═══════════════════════════════════════════════════════════
# LOGGING
# ═══════════════════════════════════════════════════════════

logger = structlog.get_logger()

# ═══════════════════════════════════════════════════════════
# FASTAPI APP
# ═══════════════════════════════════════════════════════════

app = FastAPI(
    title=settings.app_name + " V2",
    version="2.0.0",
    description="Microservicio de IA multi-módulo para Odoo 19",
    docs_url="/docs" if settings.debug else None,
    redoc_url="/redoc" if settings.debug else None,
)

# ═══════════════════════════════════════════════════════════
# MIDDLEWARE
# ═══════════════════════════════════════════════════════════

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ═══════════════════════════════════════════════════════════
# SECURITY
# ═══════════════════════════════════════════════════════════

security = HTTPBearer()

async def verify_api_key(credentials: HTTPAuthorizationCredentials = Security(security)):
    """Verifica API key en header Authorization"""
    if credentials.credentials != settings.api_key:
        logger.warning("invalid_api_key_attempt")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key"
        )
    return credentials

# ═══════════════════════════════════════════════════════════
# MODELS (PYDANTIC) - PRESERVED FOR BACKWARD COMPATIBILITY
# ═══════════════════════════════════════════════════════════

class DTEValidationRequest(BaseModel):
    """Request para validación de DTE - PRESERVED"""
    dte_data: Dict[str, Any]
    company_id: int
    history: Optional[List[Dict]] = []

class DTEValidationResponse(BaseModel):
    """Response de validación - PRESERVED"""
    confidence: float  # 0-100
    warnings: List[str]
    errors: List[str]
    recommendation: str  # 'send' o 'review'

# NEW: Generic validation models
class GenericValidationRequest(BaseModel):
    """Generic validation request for any module"""
    data: Dict[str, Any]
    context: Optional[Dict[str, Any]] = {}

class GenericValidationResponse(BaseModel):
    """Generic validation response"""
    confidence: float
    warnings: List[str]
    errors: List[str]
    recommendation: str
    module: str

# NEW: Chat session models
class NewSessionRequest(BaseModel):
    """Request to create new chat session"""
    user_context: Optional[Dict[str, Any]] = {}

class NewSessionResponse(BaseModel):
    """Response with new session info"""
    session_id: str
    welcome_message: str
    created_at: str

class ConversationHistoryResponse(BaseModel):
    """Response with conversation history"""
    session_id: str
    messages: List[Dict[str, Any]]
    stats: Dict[str, Any]

class KnowledgeSearchResponse(BaseModel):
    """Response from knowledge base search"""
    query: str
    results: List[Dict[str, Any]]
    count: int

# NEW: PO Matching models
class POMatchRequest(BaseModel):
    """Request for PO matching"""
    dte_data: Dict[str, Any]
    company_id: int
    emisor_rut: str
    monto_total: float
    fecha_emision: Optional[str] = None

class POMatchResponse(BaseModel):
    """Response with PO matching result"""
    matched_po_id: Optional[int]
    confidence: float
    line_matches: List[Dict[str, Any]]
    reasoning: str

# ═══════════════════════════════════════════════════════════
# PLUGIN SYSTEM INITIALIZATION
# ═══════════════════════════════════════════════════════════

_plugin_registry = None

def get_plugin_registry():
    """Get or initialize plugin registry"""
    global _plugin_registry
    
    if _plugin_registry is None and settings.enable_plugin_system:
        from plugins.registry import get_plugin_registry as _get_registry
        from plugins.dte.plugin import DTEPlugin
        
        _plugin_registry = _get_registry()
        
        # Register DTE plugin (always available)
        _plugin_registry.register(DTEPlugin())
        
        logger.info("plugin_system_initialized",
                   modules=_plugin_registry.list_modules())
    
    return _plugin_registry

# ═══════════════════════════════════════════════════════════
# ENDPOINTS - BACKWARD COMPATIBLE
# ═══════════════════════════════════════════════════════════

@app.get("/health")
async def health_check():
    """Health check endpoint - PRESERVED"""
    return {
        "status": "healthy",
        "service": settings.app_name,
        "version": "2.0.0",
        "anthropic_configured": bool(settings.anthropic_api_key),
        "openai_configured": bool(settings.openai_api_key),
        "plugin_system_enabled": settings.enable_plugin_system,
        "modules": get_plugin_registry().list_modules() if settings.enable_plugin_system else ["l10n_cl_dte"]
    }

@app.post("/api/ai/validate",
          response_model=DTEValidationResponse,
          dependencies=[Depends(verify_api_key)])
async def validate_dte(request: DTEValidationRequest):
    """
    Pre-validación inteligente de un DTE antes de envío al SII.
    
    BACKWARD COMPATIBLE: Funciona exactamente igual que antes.
    Internamente usa plugin system si está habilitado.
    """
    logger.info("ai_validation_started", 
               company_id=request.company_id,
               using_plugin_system=settings.enable_plugin_system)
    
    try:
        if settings.enable_plugin_system:
            # NEW: Use plugin system
            registry = get_plugin_registry()
            dte_plugin = registry.get_plugin('l10n_cl_dte')
            
            if dte_plugin is None:
                raise Exception("DTE plugin not found")
            
            result = await dte_plugin.validate(
                request.dte_data,
                {
                    'company_id': request.company_id,
                    'history': request.history
                }
            )
        else:
            # LEGACY: Use original Anthropic client directly
            from clients.anthropic_client import get_anthropic_client
            
            client = get_anthropic_client(
                settings.anthropic_api_key,
                settings.anthropic_model
            )
            
            result = client.validate_dte(request.dte_data, request.history)
        
        return DTEValidationResponse(
            confidence=result.get('confidence', 95.0),
            warnings=result.get('warnings', []),
            errors=result.get('errors', []),
            recommendation=result.get('recommendation', 'send')
        )
        
    except Exception as e:
        logger.error("ai_validation_error", error=str(e))
        
        # Retornar resultado neutro (no bloquear flujo)
        return DTEValidationResponse(
            confidence=50.0,
            warnings=[f"AI Service error: {str(e)}"],
            errors=[],
            recommendation="send"
        )

# NEW: Generic validation endpoint (only if feature flag enabled)
@app.post("/api/ai/validate/{module}",
          response_model=GenericValidationResponse,
          dependencies=[Depends(verify_api_key)])
async def validate_document(module: str, request: GenericValidationRequest):
    """
    Generic validation endpoint for any module.
    
    NEW: Only available if enable_generic_validation=True
    """
    if not settings.enable_generic_validation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Generic validation not enabled"
        )
    
    logger.info("generic_validation_started", module=module)
    
    try:
        registry = get_plugin_registry()
        plugin = registry.get_plugin(module)
        
        if plugin is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Module '{module}' not found"
            )
        
        result = await plugin.validate(request.data, request.context)
        
        return GenericValidationResponse(
            confidence=result.get('confidence', 50.0),
            warnings=result.get('warnings', []),
            errors=result.get('errors', []),
            recommendation=result.get('recommendation', 'review'),
            module=module
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("generic_validation_error", module=module, error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Validation failed: {str(e)}"
        )

# ═══════════════════════════════════════════════════════════
# CHAT SUPPORT ENDPOINTS - PRESERVED
# ═══════════════════════════════════════════════════════════

from chat.engine import ChatEngine, ChatResponse as EngineChatResponse
from chat.context_manager import ContextManager
from chat.knowledge_base import KnowledgeBase
from utils.redis_helper import get_redis_client
import uuid

class ChatMessageRequest(BaseModel):
    """Request to send chat message - PRESERVED"""
    session_id: Optional[str] = None
    message: str
    user_context: Optional[Dict[str, Any]] = None

_chat_engine: Optional[ChatEngine] = None

def get_chat_engine() -> ChatEngine:
    """Get or create chat engine singleton - PRESERVED"""
    global _chat_engine

    if _chat_engine is None:
        logger.info("chat_engine_initializing")

        redis_client = get_redis_client()

        context_manager = ContextManager(
            redis_client=redis_client,
            ttl_seconds=settings.chat_session_ttl
        )

        knowledge_base = KnowledgeBase()

        from clients.anthropic_client import get_anthropic_client
        from clients.openai_client import get_openai_client

        anthropic_client = get_anthropic_client(
            settings.anthropic_api_key,
            settings.anthropic_model
        )

        openai_client = get_openai_client(settings.openai_api_key) if settings.openai_api_key else None

        _chat_engine = ChatEngine(
            context_manager=context_manager,
            knowledge_base=knowledge_base,
            anthropic_client=anthropic_client,
            openai_client=openai_client,
            max_context_messages=settings.chat_max_context_messages,
            default_temperature=settings.chat_default_temperature
        )

        logger.info("chat_engine_initialized",
                   has_openai_fallback=openai_client is not None)

    return _chat_engine

@app.post(
    "/api/chat/message",
    response_model=EngineChatResponse,
    tags=["Chat Support"],
    summary="Send chat message - PRESERVED"
)
async def send_chat_message(
    request: ChatMessageRequest,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """Send message to AI support assistant - PRESERVED"""
    await verify_api_key(credentials)

    session_id = request.session_id or str(uuid.uuid4())

    logger.info("chat_message_request",
                session_id=session_id,
                message_preview=request.message[:100])

    try:
        engine = get_chat_engine()

        response = await engine.send_message(
            session_id=session_id,
            user_message=request.message,
            user_context=request.user_context
        )

        return response

    except Exception as e:
        logger.error("chat_message_error",
                    session_id=session_id,
                    error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Chat failed: {str(e)}"
        )

# ═══════════════════════════════════════════════════════════
# NEW CHAT SESSION ENDPOINTS
# ═══════════════════════════════════════════════════════════

@app.post(
    "/api/chat/session/new",
    response_model=NewSessionResponse,
    tags=["Chat Support"],
    summary="Create new chat session"
)
async def create_chat_session(
    request: NewSessionRequest,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """
    Create new chat session with personalized welcome message.
    
    Returns session_id and welcome message based on user context.
    """
    await verify_api_key(credentials)
    
    from datetime import datetime
    
    session_id = str(uuid.uuid4())
    
    # Build personalized welcome message
    company_name = request.user_context.get('company_name', 'tu empresa')
    environment = request.user_context.get('environment', 'Sandbox')
    user_name = request.user_context.get('user_name', '')
    
    greeting = f"¡Hola{', ' + user_name if user_name else ''}! " if user_name else "¡Hola! "
    
    welcome = f"""{greeting}Soy tu asistente especializado en Facturación Electrónica Chilena.

Estoy aquí para ayudarte con:
✅ Generación de DTEs (tipos 33, 34, 52, 56, 61)
✅ Gestión de certificados digitales y CAF
✅ Resolución de errores del SII
✅ Mejores prácticas fiscales chilenas
✅ Operación en modo contingencia

**Contexto actual:**
- Empresa: {company_name}
- Ambiente: {environment}

¿En qué puedo ayudarte hoy?"""
    
    # Save user context to Redis
    try:
        engine = get_chat_engine()
        # Store context in Redis with session_id as key
        engine.context_manager.redis_client.setex(
            f"session_context:{session_id}",
            settings.chat_session_ttl,
            str(request.user_context)
        )
        
        logger.info("chat_session_created",
                   session_id=session_id,
                   has_context=bool(request.user_context))
        
    except Exception as e:
        logger.error("session_creation_error", error=str(e))
        # Continue anyway - context is optional
    
    return NewSessionResponse(
        session_id=session_id,
        welcome_message=welcome,
        created_at=datetime.utcnow().isoformat()
    )

@app.get(
    "/api/chat/session/{session_id}",
    response_model=ConversationHistoryResponse,
    tags=["Chat Support"],
    summary="Get conversation history"
)
async def get_conversation_history(
    session_id: str,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """
    Get conversation history for a session.
    
    Returns all messages in the conversation with statistics.
    """
    await verify_api_key(credentials)
    
    try:
        engine = get_chat_engine()
        history = engine.context_manager.get_conversation_history(session_id)
        
        # Calculate stats
        user_messages = [m for m in history if m.get('role') == 'user']
        assistant_messages = [m for m in history if m.get('role') == 'assistant']
        
        logger.info("conversation_history_retrieved",
                   session_id=session_id,
                   message_count=len(history))
        
        return ConversationHistoryResponse(
            session_id=session_id,
            messages=history,
            stats={
                'message_count': len(history),
                'user_messages': len(user_messages),
                'assistant_messages': len(assistant_messages),
                'has_context': bool(history)
            }
        )
        
    except Exception as e:
        logger.error("get_history_error",
                    session_id=session_id,
                    error=str(e))
        # Return empty history instead of error
        return ConversationHistoryResponse(
            session_id=session_id,
            messages=[],
            stats={
                'message_count': 0,
                'user_messages': 0,
                'assistant_messages': 0,
                'has_context': False
            }
        )

@app.delete(
    "/api/chat/session/{session_id}",
    tags=["Chat Support"],
    summary="Clear chat session"
)
async def clear_chat_session(
    session_id: str,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """
    Clear chat session (delete history and context).
    
    Removes all conversation history and user context from Redis.
    """
    await verify_api_key(credentials)
    
    try:
        engine = get_chat_engine()
        
        # Clear conversation history
        history_key = f"conversation:{session_id}"
        context_key = f"session_context:{session_id}"
        
        engine.context_manager.redis_client.delete(history_key)
        engine.context_manager.redis_client.delete(context_key)
        
        logger.info("chat_session_cleared", session_id=session_id)
        
        return {
            'success': True,
            'session_id': session_id,
            'message': 'Session cleared successfully'
        }
        
    except Exception as e:
        logger.error("clear_session_error",
                    session_id=session_id,
                    error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to clear session: {str(e)}"
        )

@app.get(
    "/api/chat/knowledge/search",
    response_model=KnowledgeSearchResponse,
    tags=["Chat Support"],
    summary="Search knowledge base"
)
async def search_knowledge_base(
    query: str,
    top_k: int = 3,
    module: Optional[str] = None,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """
    Search knowledge base directly without chat session.
    
    Useful for quick documentation lookups.
    
    Args:
        query: Search query
        top_k: Number of results to return (default: 3)
        module: Filter by module (e.g., 'l10n_cl_dte')
    """
    await verify_api_key(credentials)
    
    try:
        engine = get_chat_engine()
        
        # Build filters
        filters = {'module': module} if module else None
        
        # Search knowledge base
        results = engine.knowledge_base.search(
            query=query,
            top_k=top_k,
            filters=filters
        )
        
        logger.info("knowledge_base_searched",
                   query=query,
                   results_count=len(results),
                   module=module)
        
        return KnowledgeSearchResponse(
            query=query,
            results=results,
            count=len(results)
        )
        
    except Exception as e:
        logger.error("knowledge_search_error",
                    query=query,
                    error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Knowledge search failed: {str(e)}"
        )

@app.post(
    "/api/ai/reception/match_po",
    response_model=POMatchResponse,
    tags=["DTE Reception"],
    summary="Match received DTE with Purchase Orders"
)
async def match_purchase_order(
    request: POMatchRequest,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """
    Match received DTE with purchase orders using AI.
    
    Analyzes DTE data and attempts to find matching PO using Claude.
    Returns matched PO ID with confidence score.
    """
    await verify_api_key(credentials)
    
    logger.info("po_matching_started",
               company_id=request.company_id,
               emisor_rut=request.emisor_rut,
               monto_total=request.monto_total)
    
    try:
        # TODO: Implement full PO matching logic with Claude
        # For now, return no match (graceful degradation)
        
        logger.info("po_matching_completed",
                   matched=False,
                   reason="Matching logic not yet implemented")
        
        return POMatchResponse(
            matched_po_id=None,
            confidence=0.0,
            line_matches=[],
            reasoning="Matching automático de Purchase Orders en desarrollo. Por favor, realice matching manual."
        )
        
    except Exception as e:
        logger.error("po_matching_error",
                    company_id=request.company_id,
                    error=str(e))
        
        # Return no match instead of error (don't block workflow)
        return POMatchResponse(
            matched_po_id=None,
            confidence=0.0,
            line_matches=[],
            reasoning=f"Error en matching: {str(e)}"
        )

# ═══════════════════════════════════════════════════════════
# SII MONITORING - PRESERVED
# ═══════════════════════════════════════════════════════════

class SIIMonitorRequest(BaseModel):
    """Request for SII monitoring - PRESERVED"""
    force: bool = False

@app.post("/api/ai/sii/monitor",
          dependencies=[Depends(verify_api_key)],
          tags=["SII Monitoring"])
async def monitor_sii(request: SIIMonitorRequest):
    """Monitor SII website for changes - PRESERVED"""
    logger.info("sii_monitor_triggered", force=request.force)
    
    try:
        from sii_monitor.orchestrator import MonitoringOrchestrator
        
        orchestrator = MonitoringOrchestrator()
        result = await orchestrator.run_monitoring_cycle(force=request.force)
        
        return {
            "status": "completed",
            "changes_detected": result.get('changes_detected', False),
            "notifications_sent": result.get('notifications_sent', 0)
        }
        
    except Exception as e:
        logger.error("sii_monitor_error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Monitoring failed: {str(e)}"
        )

# ═══════════════════════════════════════════════════════════
# STARTUP/SHUTDOWN - ENHANCED
# ═══════════════════════════════════════════════════════════

@app.on_event("startup")
async def startup_event():
    """Initialize services on startup"""
    logger.info("ai_service_starting",
               version="2.0.0",
               plugin_system=settings.enable_plugin_system)
    
    # Initialize plugin system if enabled
    if settings.enable_plugin_system:
        registry = get_plugin_registry()
        logger.info("plugins_loaded",
                   modules=registry.list_modules())

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    logger.info("ai_service_stopping")
