# PROMPT: Implementar Parser Estructurado de Outputs CLI

**CONTEXTO:**
Los CLI (Copilot, Gemini, Codex) devuelven texto Markdown sin estructura. Necesitamos extraer hallazgos (findings) de forma programática para tomar decisiones.

**OBJETIVO:**
Implementar `docs/prompts/prompts_sdk/utils/parse_cli_output.py` con parsers robustos que extraigan:
- Findings (P0/P1/P2/P3/P4)
- Metadata (score, módulo, timestamp)
- Métricas (tokens, tiempo ejecución)
- Test results (passed, failed, coverage)

**INPUTS DISPONIBLES:**

1. **Ejemplos outputs reales:**
   - Busca en `docs/prompts/06_outputs/2025-11/auditorias/` outputs ejemplo
   - Analiza patrones comunes en reportes Markdown

2. **Estructura datos esperada:**
```python
# Ver docs/prompts/prompts_sdk/core/audit.py
@dataclass
class Finding:
    id: str
    severity: str  # P0, P1, P2, P3, P4
    category: str
    title: str
    description: str
    file: Optional[str] = None
    line: Optional[int] = None
    odoo19_compliance: bool = False
    recommendation: Optional[str] = None
```

**REQUERIMIENTOS:**

## 1. Parser Principal

```python
# docs/prompts/prompts_sdk/utils/parse_cli_output.py

from typing import List, Optional, Dict, Any
from dataclasses import dataclass
import re
from datetime import datetime
from prompts_sdk.core.audit import Finding, AuditResult

class CLIOutputParser:
    """Parse CLI outputs (Copilot, Gemini, Codex) to structured data."""

    @staticmethod
    def parse_audit_report(
        output: str,
        cli_tool: str = "copilot"
    ) -> AuditResult:
        """
        Parse audit report from CLI output.

        Args:
            output: Raw CLI output (Markdown)
            cli_tool: CLI used (copilot, gemini, codex)

        Returns:
            AuditResult with parsed findings

        Examples:
            >>> output = '''
            ... ## Hallazgos
            ... - [P0] t-esc encontrado en views/invoice.xml línea 45
            ... - [P1] self._cr en models/account.py línea 123
            ... '''
            >>> result = CLIOutputParser.parse_audit_report(output)
            >>> len(result.findings)
            2
            >>> result.findings[0].severity
            'P0'
        """
        # TODO: Implementar parsing robusto

    @staticmethod
    def extract_findings(output: str) -> List[Finding]:
        """
        Extract findings from Markdown output.

        Patterns to detect:
        - [P0] Description (file.py:123)
        - **P1:** Description in path/file.ext line 45
        - ❌ P2 - Title: Description
        - P3: Title (location: file.xml:67)

        Returns:
            List of Finding objects
        """
        # TODO: Implementar regex patterns

    @staticmethod
    def extract_score(output: str) -> Optional[float]:
        """
        Extract compliance score from output.

        Patterns:
        - Score: 85/100
        - Compliance: 75%
        - **Score Global:** 92.5/100

        Returns:
            Score as float (0-100) or None
        """
        # TODO: Implementar

    @staticmethod
    def extract_metadata(output: str) -> Dict[str, Any]:
        """
        Extract metadata (module, timestamp, etc).

        Returns:
            Dict with metadata
        """
        # TODO: Implementar

    @staticmethod
    def parse_test_results(output: str) -> Dict[str, Any]:
        """
        Parse pytest output.

        Extract:
        - tests_passed
        - tests_failed
        - coverage_percentage
        - duration_seconds

        Returns:
            Dict with test metrics
        """
        # TODO: Implementar
```

## 2. Regex Patterns Robustos

Implementa patterns que capturen TODAS estas variantes:

```python
FINDING_PATTERNS = [
    # Pattern 1: [P0] Description (file.py:123)
    r'\[(?P<severity>P[0-4])\]\s+(?P<description>.+?)\s*\((?P<file>[^:)]+):(?P<line>\d+)\)',

    # Pattern 2: **P1:** Description in path/file.ext line 45
    r'\*\*(?P<severity>P[0-4]):\*\*\s+(?P<description>.+?)\s+in\s+(?P<file>\S+)\s+line\s+(?P<line>\d+)',

    # Pattern 3: ❌ P2 - Title: Description
    r'[❌✗]\s*(?P<severity>P[0-4])\s*-\s*(?P<title>[^:]+):\s*(?P<description>.+)',

    # Pattern 4: P3: Title (location: file.xml:67)
    r'(?P<severity>P[0-4]):\s*(?P<title>[^(]+)\s*\(location:\s*(?P<file>[^:)]+):(?P<line>\d+)\)',

    # Add more patterns for edge cases
]
```

## 3. Tests Completos

```python
# docs/prompts/prompts_sdk/utils/test_parse_cli_output.py

import pytest
from prompts_sdk.utils.parse_cli_output import CLIOutputParser

def test_parse_simple_finding():
    output = "[P0] t-esc found in views/invoice.xml:45"
    findings = CLIOutputParser.extract_findings(output)

    assert len(findings) == 1
    assert findings[0].severity == "P0"
    assert findings[0].file == "views/invoice.xml"
    assert findings[0].line == 45

def test_parse_multiple_findings():
    output = """
    ## Hallazgos Críticos
    - [P0] Usar t-out en lugar de t-esc (views/invoice_form.xml:23)
    - [P1] Reemplazar self._cr por self.env.cr (models/account_move.py:156)
    - [P2] Agregar tests unitarios (tests/test_account.py:0)
    """
    findings = CLIOutputParser.extract_findings(output)

    assert len(findings) == 3
    assert findings[0].severity == "P0"
    assert findings[1].severity == "P1"
    assert findings[2].severity == "P2"

def test_extract_score():
    output = "Score Global: 87.5/100"
    score = CLIOutputParser.extract_score(output)
    assert score == 87.5

def test_parse_full_audit_report():
    # Use real example from docs/prompts/06_outputs/
    with open("docs/prompts/06_outputs/2025-11/auditorias/backend_report_2025-11-12.md") as f:
        output = f.read()

    result = CLIOutputParser.parse_audit_report(output)

    assert result.score > 0
    assert len(result.findings) > 0
    assert result.module_path != ""

# Add 15+ more tests covering edge cases
```

## 4. Error Handling

```python
class ParseError(Exception):
    """Raised when parsing fails."""
    pass

def safe_parse(output: str) -> AuditResult:
    """Parse with error handling."""
    try:
        return CLIOutputParser.parse_audit_report(output)
    except Exception as e:
        # Log error
        # Save raw output to logs/
        # Return partial result
        return AuditResult(
            session_id="error",
            timestamp=datetime.now(),
            module_path="unknown",
            dimensions=[],
            score=0.0,
            findings=[],
            metadata={"parse_error": str(e), "raw_output_saved": True}
        )
```

**OUTPUTS ESPERADOS:**

1. `docs/prompts/prompts_sdk/utils/parse_cli_output.py` (500+ líneas)
2. `docs/prompts/prompts_sdk/utils/test_parse_cli_output.py` (300+ líneas)
3. Todos los tests passing (pytest)

**RESTRICCIONES:**

- NO usar bibliotecas externas (solo stdlib + pytest)
- Regex patterns DEBEN ser robustos (capturar variantes)
- Tests DEBEN usar ejemplos reales del proyecto
- Error handling completo (no crashes)

**VALIDACIÓN:**

Ejecutar:
```bash
cd docs/prompts
pytest prompts_sdk/utils/test_parse_cli_output.py -v
# Todos los tests DEBEN pasar
```

**EJECUTA AHORA:** Implementa el parser completo con tests.
