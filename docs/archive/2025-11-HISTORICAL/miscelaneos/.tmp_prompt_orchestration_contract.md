# PROMPT: DiseÃ±o Contrato de OrquestaciÃ³n Claude Code

**CONTEXTO:**
Eres un arquitecto de sistemas multi-agente. EstÃ¡s diseÃ±ando el "contrato de orquestaciÃ³n" para Claude Code, que actuarÃ¡ como orquestador maestro coordinando CLI agentes (Copilot, Gemini, Codex) para lograr objetivos 100/100 de forma autÃ³noma.

**OBJETIVO:**
Crear documento `ORQUESTACION_CLAUDE_CODE.md` que defina:
1. Flujo estÃ¡ndar completo: Audit â†’ Investigate â†’ Gap Closure â†’ Develop â†’ Test â†’ Re-audit
2. Mapping templates â†’ comandos CLI especÃ­ficos
3. Restricciones crÃ­ticas que requieren confirmaciÃ³n
4. LÃ³gica iterativa hasta 100/100 o max_iterations
5. Error recovery strategies
6. Budget & iterations tracking

**INPUTS DISPONIBLES (LEE TODOS):**

1. **Knowledge Base Completa:**
   - `docs/prompts/00_knowledge_base/` (7 documentos tÃ©cnicos)
   - Stack, Odoo 19 patterns, compliance, SII regulations

2. **Templates Existentes:**
   - `docs/prompts/04_templates/TEMPLATE_MULTI_AGENT_ORCHESTRATION.md`
   - `docs/prompts/04_templates/TEMPLATE_P4_DEEP_ANALYSIS.md`
   - `docs/prompts/04_templates/TEMPLATE_AUDITORIA.md`
   - 8 templates mÃ¡s en total

3. **Scripts Existentes:**
   - `docs/prompts/08_scripts/ciclo_completo_auditoria_v2.sh`
   - `docs/prompts/08_scripts/orquestar_auditoria_dte_360.sh`
   - 13 scripts automatizaciÃ³n

4. **SDK Actual:**
   - `docs/prompts/prompts_sdk/agents/orchestrator.py` (ejecuta agentes)
   - `docs/prompts/prompts_sdk/core/audit.py` (modelos de datos)

5. **Compliance & MÃ¡ximas:**
   - `docs/prompts/02_compliance/CHECKLIST_ODOO19_VALIDACIONES.md`
   - `docs/prompts/03_maximas/MAXIMAS_DESARROLLO.md`
   - `docs/prompts/03_maximas/MAXIMAS_AUDITORIA.md`

**REQUERIMIENTOS ESPECÃFICOS:**

## 1. Flujo EstÃ¡ndar Completo

DiseÃ±a el flujo que Claude Code seguirÃ¡ cuando reciba instrucciÃ³n tipo:
```
"Claude, audita y mejora el microservicio AI hasta 100/100 compliance y features completas"
```

Debe incluir:
- **Fase 1: Discovery** (entender propÃ³sito mÃ³dulo/servicio)
- **Fase 2: Audit** (identificar brechas compliance, bugs, mejoras)
- **Fase 3: Gap Closure** (cerrar P0/P1 automÃ¡ticamente, P2+ con confirmaciÃ³n)
- **Fase 4: Enhancement** (identificar nuevas features basadas en objetivo)
- **Fase 5: Development** (implementar features aprobadas)
- **Fase 6: Testing** (pytest, coverage >80%)
- **Fase 7: Re-audit** (validar score 100/100)
- **Fase 8: Iteration** (volver a Fase 2 si score < 100, hasta max_iterations)

## 2. Mapping Templates â†’ Comandos CLI

Para cada fase, especifica:
- Template a usar
- CLI Ã³ptimo (Copilot/Gemini/Codex)
- Modelo recomendado
- Comando exacto con flags

Ejemplo:
```yaml
Fase_2_Audit_Compliance:
  template: docs/prompts/04_templates/TEMPLATE_AUDITORIA.md
  cli: copilot
  model: claude-sonnet-4.5
  comando: |
    copilot -p "$(cat {TEMPLATE_PATH} | sed 's/{{MODULE}}/{MODULE_NAME}/g')" \
      --allow-all-tools --allow-all-paths \
      > {OUTPUT_PATH}
  timeout: 300
  retry_on_failure: true
  max_retries: 2
```

## 3. Restricciones CrÃ­ticas (Solicitar ConfirmaciÃ³n)

Define EXACTAMENTE cuÃ¡ndo Claude Code debe usar `AskUserQuestion`:

```python
# Ejemplo restricciones
CRITICAL_OPERATIONS = {
    "mass_deletion": {
        "trigger": "files_to_delete > 10 OR lines_to_delete > 500",
        "question": "âš ï¸ OperaciÃ³n destructiva detectada: Eliminar {count} archivos. Â¿Proceder?",
        "options": ["SÃ­, proceder", "No, cancelar", "Revisar lista primero"]
    },
    "module_creation": {
        "trigger": "mkdir addons/* OR crear nuevo __manifest__.py",
        "question": "âš ï¸ CreaciÃ³n mÃ³dulo nuevo '{name}' detectada. Â¿Aprobar?",
        "options": ["SÃ­, crear mÃ³dulo", "No, detener"]
    },
    "db_migration": {
        "trigger": "ALTER TABLE OR CREATE TABLE en .sql",
        "question": "âš ï¸ Cambio DB schema detectado. Requiere migraciÃ³n manual. Â¿Continuar?",
        "options": ["SÃ­, revisar migraciÃ³n", "No, detener"]
    },
    "max_iterations_reached": {
        "trigger": "current_iteration >= max_iterations",
        "question": "â±ï¸ Alcanzado lÃ­mite {max} iteraciones. Score actual: {score}/100. Â¿Continuar?",
        "options": ["SÃ­, 5 iteraciones mÃ¡s", "No, detener y reportar", "Revisar hallazgos pendientes"]
    },
    "budget_exceeded": {
        "trigger": "current_cost_usd >= max_budget_usd * 0.8",
        "question": "ðŸ’° Presupuesto al 80% (${current}/${max}). Â¿Continuar?",
        "options": ["SÃ­, aumentar budget a ${new}", "No, detener"]
    }
}
```

## 4. LÃ³gica Iterativa 100/100

PseudocÃ³digo completo de la lÃ³gica iterativa:

```python
def orchestrate_to_perfection(module_path, objective, max_iterations=10, max_budget=5.0):
    """
    Orquestar hasta score 100/100 o lÃ­mites alcanzados.
    """
    session = OrchestrationSession(max_iterations, max_budget)

    # Fase 1: Discovery
    module_info = discover_module_purpose(module_path)

    while session.should_continue():
        session.increment_iteration()

        # Fase 2: Audit
        audit_result = run_multi_agent_audit(module_path)

        # Fase 3: Gap Closure
        if audit_result.critical_count > 0:
            confirmed = ask_user_confirmation(f"Cerrar {audit_result.critical_count} brechas P0?")
            if confirmed:
                close_gaps(audit_result.findings_P0)

        # Fase 4-5: Enhancement + Development
        if audit_result.score >= 80 and session.iteration == 1:
            features = identify_new_features(module_info, objective)
            confirmed_features = ask_user_confirmation(f"Desarrollar {len(features)} features?")
            if confirmed_features:
                develop_features(features)

        # Fase 6: Testing
        test_result = run_tests(module_path)
        if test_result.coverage < 80:
            generate_missing_tests(test_result.uncovered_lines)

        # Fase 7: Re-audit
        final_score = re_audit(module_path)

        if final_score >= 100:
            return success_report(session)

        # Check limits
        if session.budget_exceeded():
            confirmed = ask_user_confirmation("Budget exceeded, continue?")
            if not confirmed:
                return partial_report(session, final_score)

    # Max iterations reached
    return partial_report(session, final_score)
```

## 5. Error Recovery

Estrategias cuando CLI falla:

```yaml
Error_Recovery_Strategies:

  copilot_timeout:
    detection: "exit_code == 124 OR timeout exceeded"
    actions:
      1. Retry con timeout 2x (600s)
      2. Si falla, dividir tarea en chunks
      3. Si falla, usar Gemini como backup

  parsing_failed:
    detection: "No se pudo extraer findings del output"
    actions:
      1. Guardar output raw en logs/
      2. Notificar usuario para review manual
      3. Continuar con siguientes fases

  test_failures:
    detection: "pytest exit_code != 0"
    actions:
      1. Analizar traceback
      2. Si <5 tests fallan: Auto-fix con Codex
      3. Si >=5 tests: Solicitar confirmaciÃ³n usuario

  git_conflicts:
    detection: "CONFLICT detected en git status"
    actions:
      1. Stash cambios
      2. Notificar usuario
      3. Detener orquestaciÃ³n
```

## 6. Budget & Iterations Tracking

Estructura de datos:

```python
@dataclass
class OrchestrationSession:
    session_id: str
    start_time: datetime
    max_iterations: int = 10
    max_budget_usd: float = 5.0

    current_iteration: int = 0
    current_cost_usd: float = 0.0

    audit_results: List[AuditResult] = field(default_factory=list)
    actions_taken: List[Action] = field(default_factory=list)
    confirmations_asked: List[Confirmation] = field(default_factory=list)

    def should_continue(self) -> bool:
        return (self.current_iteration < self.max_iterations and
                self.current_cost_usd < self.max_budget_usd)

    def add_cost(self, tokens_input: int, tokens_output: int, model: str):
        # Pricing per model
        PRICING = {
            "claude-sonnet-4.5": {"input": 0.003, "output": 0.015},  # per 1K tokens
            "gpt-4o": {"input": 0.005, "output": 0.015},
            "gemini-flash-pro": {"input": 0.001, "output": 0.002}
        }
        cost = (tokens_input/1000 * PRICING[model]["input"] +
                tokens_output/1000 * PRICING[model]["output"])
        self.current_cost_usd += cost
```

**OUTPUT ESPERADO:**

Documento Markdown `ORQUESTACION_CLAUDE_CODE.md` con:

1. Header con metadata
2. IntroducciÃ³n propÃ³sito
3. SecciÃ³n "Flujo EstÃ¡ndar Completo" (detallado)
4. SecciÃ³n "Mapping Templates â†’ CLI" (tabla completa)
5. SecciÃ³n "Restricciones CrÃ­ticas" (cÃ³digo Python)
6. SecciÃ³n "LÃ³gica Iterativa" (pseudocÃ³digo completo)
7. SecciÃ³n "Error Recovery" (estrategias yaml)
8. SecciÃ³n "Budget Tracking" (dataclass Python)
9. SecciÃ³n "Ejemplos de Uso" (3 casos: audit simple, desarrollo features, migraciÃ³n completa)
10. SecciÃ³n "Testing & Validation" (cÃ³mo validar el contrato)

**RESTRICCIONES:**

- DEBE ser 100% ejecutable (no conceptual)
- DEBE referenciar archivos reales del proyecto
- DEBE ser coherente con templates/scripts/SDK existentes
- DEBE incluir comandos CLI reales ejecutables
- DEBE tener ejemplos concretos (no placeholders genÃ©ricos)

**ESTILO:**

- Profesional, preciso, ejecutable
- CÃ³digo real Python/Bash (no pseudocÃ³digo vago)
- YAML para configuraciones
- Markdown con tablas, cÃ³digo, diagramas mermaid

**VALIDACIÃ“N:**

Antes de entregar, verifica:
- [ ] Â¿Cubre flujo completo Discovery â†’ Iteration?
- [ ] Â¿Incluye TODOS los templates existentes en mapping?
- [ ] Â¿Define restricciones crÃ­ticas ejecutables?
- [ ] Â¿PseudocÃ³digo es traducible a Python real?
- [ ] Â¿Error recovery cubre casos reales?
- [ ] Â¿Budget tracking tiene pricing real?

---

**EJECUTA AHORA:** DiseÃ±a el documento completo.
